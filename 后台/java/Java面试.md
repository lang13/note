#### Java中的方法覆盖(Overriding)和方法重载(Overload)是什么意思？

> Java中的方法重载发生在同一个类里面两个或者是多个方法的方法名相同但是参数不同的情况。与此相对，方法覆盖是说子类重新定义了父类的方法。方法覆盖必须有相同的方法名，参数列表和返回类型。覆盖者可能不会限制它所覆盖的方法的访问。

#### 接口和抽象类的区别是什么？

>Java提供和支持创建抽象类和接口。它们的实现有共同点，不同点在于：
>接口中所有的方法隐含的都是抽象的。而抽象类则可以同时包含抽象和非抽象的方法。
>类可以实现很多个接口，但是只能继承一个抽象类
>类可以不实现抽象类和接口声明的所有方法，当然，在这种情况下，类也必须得声明成是抽象的。
>抽象类可以在不提供接口方法实现的情况下实现接口。
>Java接口中声明的变量默认都是final的。抽象类可以包含非final的变量。
>Java接口中的成员函数默认是public的。抽象类的成员函数可以是private，protected或者是public。
>接口是绝对抽象的，不可以被实例化，抽象类也不可以被实例化。
>也可以参考JDK8中抽象类和接口的区别
>
>**从设计层面来说，抽象是对类的抽象，是一种模板设计，接口是行为的抽象，是一种行为的规范。**

#### 进程和线程的区别是什么？

> 进程是执行着的应用程序，而线程是进程内部的一个执行序列。一个进程可以有多个线程。线程又叫做轻量级进程。
>
> **线程与进程的区别归纳：**
>
> **a.地址空间和其它资源**：进程间相互独立，同一进程的各线程间共享。某进程内的线程在其它进程不可见。
>
> **b.通信：**进程间通信**IPC**，线程间可以直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性。
>
> **c.调度和切换**：线程上下文切换比进程上下文切换要快得多。
>
> d.在多线程OS中，进程不是一个可执行的实体。
>
> **进程间通信（IPC）**：每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信（IPC，InterProcess Communication）**

#### 什么是死锁(deadlock)？

> 所谓死锁是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。死锁产生的4个必要条件：
>
> - 互斥条件：进程要求对所分配的资源（如打印机）进行排他性控制，即在一段时间内某 资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。
> - 不剥夺条件：进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，即只能 由获得该资源的进程自己来释放（只能是主动释放)。
> - 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源 已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
> - 循环等待条件：存在一种进程资源的循环等待链，链中每一个进程已获得的资源同时被 链中下一个进程所请求。

#### 什么是迭代器(Iterator)？

> Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的
>
> 迭代方法。迭代器可以在迭代的过程中删除底层集合的元素,但是不可以直接调用集合的
>
> remove(Object Obj)删除，可以通过迭代器的remove()方法删除。

测