### OOP七大原则

<img src="../../static/image/image-20210320131143259.png" alt="image-20210320131143259" style="zoom:66%;" />

### 单例模式

#### 概念

> 百度百科是这样定义的：单例模式是一种常用的软件设计模式。在它的核心结构中只包含一个被称为单例的特殊类。通过单例模式可以保证==系统中一个类只有一个实例==。

#### 单例模式分类

> A、懒汉单例模式：在第一次调用的时候实例化本身，在并发环境下，可能出现多个本身对象。所以线程是不安全的。
>
> B、饿汉单例模式：在类初始化时，已经自行实例化一个静态对象，所以本身就是线程安全的。
>
> C、登记单例模式：通过一个专门的类对各单例模式的单一实例进行管理和维护。

#### 特点

> A、 单例模式类只能有一个实例
> B、 单例模式类必须自己创建自己的唯一实例
> C、 单例模式类必须给所有其他对象提供这一实例

#### 实现

##### 懒汉式单例模式 

```java
// 线程不安全
public class SingLeto{
    /**
     * 该函数限制用户主动创建实例
     */
    // 所以构建方法必须私有化
    private SingLeto(){}
    
    //唯一实例，先置空
    private static SingLeto singLeto = null;
    
    /**
     * 获取SingLeto实例 (也称为静态工厂)
     */
    // 给 getSingLeto 加上 synchronized 可使现线程安全
    public static SingLeto getSingLeto(){
        // 当singLeto 为空时, 实例化singLeto
        if(singLeto == null){
            singLeto = new SingLeto();
        }
        return singLeto;
    }
}

// 双重检验模式
public class Singleton {

	/**
	 * 该函数限制用户主动创建实例
	 */
	private Singleton() {}
	// 添加了 volatile 字段
    如果不添加，那么实例化的那个线程可能先在cash中实例化，但未将结果刷入内存。导致判空有误
	private volatile static Singleton singleton = null;

	/**
	 * 获取Singleton实例，也叫静态工厂方法
	 * @return Singleton
	 */
	public static Singleton getInstance() {
		if (singleton == null) {
			synchronized (Singleton.class) {
				if (singleton == null) {
					singleton = new Singleton();
				}
			}
		}
		return singleton;
	}

}

/**
 * 描述：懒汉单例模式 ，静态内部类<p>
 * 作者： kimball <p>
 * E-mail: kimballlu@foxmail.com <p>
 * 日期：2016-11-16 下午4:30:32 <p>
 */
public class Singleton {

	/**
	 * 静态内部类
	 * @author kimball
	 *
	 */
	private static class LazyHolder {
		// 创建Singleton实例
       /**
       Java机制规定，内部类 LazyHolder只有在getInstance()方法第一次调用的时候才会被加载（实现了延迟加载效果），而且其加		载过程是线程安全的（实现线程安全）
       */
        // final 修饰 Singleto字段 保证Singleto的唯一性
		private static final Singleton INSTANCE = new Singleton();
	}

	/**
	 * 该函数限制用户主动创建实例
	 */
	private Singleton() {}

	/**
	 * 获取Singleton实例，也叫静态工厂方法
	 * @return Singleton
	 */
	public static final Singleton getInstance() {
		return LazyHolder.INSTANCE;
	}
}
```

##### 饿汉式单例模式

==和懒汉单例模式中的静态内部类格式很像==

```java
/**
 * 描述：饿汉单例模式<p>
 * 作者： kimball <p>
 * E-mail: kimballlu@foxmail.com <p>
 * 日期：2016-11-16 下午4:30:32 <p>
 */
public class Singleton {

	/**
	 * 该函数限制用户主动创建实例
	 */
	private Singleton() {}

	private static final Singleton singleton = new Singleton();

	/**
	 * 获取Singleton实例，也叫静态工厂方法
	 * @return Singleton
	 */
	public static Singleton getInstance() {
		return singleton;
	}

}
```

##### 登记单例模式

```java
/**
 * 描述：登记单例模式<p>
 * 作者： kimball <p>
 * E-mail: kimballlu@foxmail.com <p>
 * 日期：2016-11-16 下午4:30:32 <p>
 */
public class Singleton {

	// 存储需要进行维护和管理的类的实例
	private static Map<String, Singleton> map = new HashMap<String, Singleton>();
	
	/**
	 * 静态创建实例并添加到Map集合
	 */
	static {
		Singleton singleton = new Singleton();
		map.put(singleton.getClass().getName(), singleton);
	}

	/**
	 * 该函数限制用户主动创建实例
	 */
	private Singleton() {};

	/**
	 * 获取Singleton实例，也叫静态工厂方法
	 * @return Singleton
	 */
	public static Singleton getInstance(String name) {
		/* 根据指定的类的名称从mao中获取实例并返回 */
		return map.get(name);
	}

	// 一个示例性的商业方法
	public String about() {
		return "你好,我是RegSingleton";
	}

	public static void main(String[] args) {
		Singleton singleton = Singleton.getInstance("com.Singleton");
		System.out.println(singleton.about());
	}
}
```

##### 枚举单例模式

```java
public emm EnumSingle{
    INSTANCE;
    
    public EnumSingle getInstance(){
        return INSTANCE;
    }
}
```



### 工厂模式

#### 核心

> - 实例化对象不适用new，用工厂方法代替
> - 将选择实现类，创建对象同意管理和控制。从而将调用者跟我们的实现类解耦

#### 作用

> Factroy要解决的问题是：**希望能够创建一个对象，但创建过程比较复杂，希望对外隐藏这些细节。**
>
> 请特别留意“**创建过程比较复杂**“这个条件。如果不复杂，用构造函数就够了。比如你想用一个HashMap时也要搞一个factory，这就很中2了。

好，那什么是“复杂的创建过程呢“？举几个==例子：==

**例子1:** 创建对象可能是一个pool里的，不是每次都凭空创建一个新的。而pool的大小等参数可以用另外的逻辑去控制。比如连接池对象，线程池对象就是个很好的例子。

**例子2:** 对象代码的作者希望隐藏对象真实的的类型，而构造函数一定要真实的类名才能用。比如作者提供了

```java
abstract class Foo { 
 //...
}
```

而真实的实现类是

```java
public class FooImplV1 extends Foo {
  // ...
}
```

但他不希望你知道FooImplV1的存在（没准下次就改成V2了），只希望你知道Foo，所以他必须提供某种类似于这样的方式让你用：

```java
Foo foo = FooCreator.create();
// do something with foo ...
```

**例子3:** 对象创建时会有很多参数来决定如何创建出这个对象。比如你有一个数据写在文件里，可能是xml也可能是json。这个文件的数据可以变成一个对象，大概就可以搞成。

```java
Foo foo = FooCreator.fromFile("/path/to/the/data-file.ext");
```

再比如这个文件是描述一个可以显示在浏览器的UI的基础数据。而不同浏览器可以正确显示的需要的数据不太一样。这个“不一样”可以表达为：

```java
Foo foo = FooCreator.fromFile("/path/to/the/data-file.ext", BrowserType.CHROME);
```

这里第二个参数"BrowserType"是一个枚举，表示如何去生成指定要求的对象。所以这个fromFile内部可能是：

```java
public Foo fromFile(String path, BrowserType type) {
  byte[] bytes = Files.load(path);
  switch (type) {
     case CHROME: return new FooChromeImpl(bytes);
     case IE8: return new FooIE8V1Impl(bytes);
     // ...
  }
}    
```

当然，实际场景可能会复杂得多，会有大量的配置参数。

```java
Foo foo = FooCreator.fromFile("....", param1, param2, param3, ...);
```

如果需要，可以帮params弄成一个Config对象。而如果这个Config对象也很复杂，也许还得给Config弄个Factory。如果Factory本身的创建也挺复杂呢？嗯，弄个Factory的Factory。

**例子4：**简化一些常规的创建过程。上面可以看到根据配置去创建一个对象也很复杂。但可能95%的情况我们就创建某个特定类型的对象。这时可以弄个函数直接省略那些配置过程。纯粹就是为了方便。

```java
Foo foo = FooCreator.chromeFromFile("/path/to/the/date-file.ext");
```

现实当中，比如Java的线程池的相关创建api（如`Executors.newFixedThreadPool`等）就是这么干的。

**例子5:** 创建一个对象有复杂的依赖关系，比如Foo对象的创建依赖A，A又依赖B，B又依赖C……。于是创建过程是一组对象的的创建和注入。手写太麻烦了。所以要把创建过程本身做很好地维护。对，==Spring IoC就是这么干的。==

**例子6:** 你知道怎么创建一个对象，但是无法把控创建的时机。你需要把“如何创建”的代码塞给“负责什么时候创建”的代码。后者在适当的时机，就回调创建的函数。

在支持用函数传参的语言，比如js，go等，直接塞创建函数就行了。对于名词王国java，就得搞个XXXXFactory的类再去传。Spring IoC 也利用了这个机制，可以了解下`FactoryBean` 

**例子7:** 避免在构造函数中抛出异常。=="构造函数里不要抛出异常"==这条原则很多人都知道。不在这里展开讨论。但问题是，业务要求必须在这里抛一个异常怎么办？就像上面的`Foo`要求从文件读出来数据并创建对象。但如果文件不存在或者磁盘有问题读不出来都会抛异常。因此用`FooCreator.fromFile`这个工厂来搞定异常这件事。 

其实还有很多例子，就不继续扩展了。要点是，当你有任何复杂的的创建对象过程时，你都需要写一个某种createXXXX的函数帮你实现。再拓展一下范围，哪怕创建的不是对象，而是任何资源，也都得这么干。一句话：

**不管你用什么语言，创建什么资源。当你开始为“创建”本身写代码的时候，就是在使用“工厂模式”了。**

#### 实现

> 准备一个接口和一个实现类

```java
//接口
public interface Car {
    void name();
}

//实现类
public class Tesla implements Car{
    @Override
    public void name() {
        System.out.println("特斯拉");
    }
}
public class WuLing implements Car {
    @Override
    public void name() {
        System.out.println("五菱宏光");
    }
}
```

##### 简单工厂模式

```java
public class CarFactory {
    //方法一
    public static Car getCar(String name){
        switch (name){
            case "五菱":
                return new WuLing();
            case "特斯拉":
                return new Tesla();
            default:
                return null;
        }
    }
    //方法二
    public static Car getWuLing(){
        return new WuLing();
    }
    public static Car getTesLa(){
        return new TesLa();
    }
}
```

##### 工厂方法模式

```java
//准备一个工厂接口
public interface CarFactory {
    Car getCar();
}

//各自准备各自的工厂
public class TeslaFactory implements CarFactory{
    @Override
    public Car getCar() {
        return new Tesla();
    }
}

public class WuLingFactory implements CarFactory{
    @Override
    public Car getCar() {
        return new WuLing();
    }
}

//获得实例
public static void main(String[] args) {
        Car car = new TeslaFactory().getCar();
        Car car1 = new WuLingFactory().getCar();
}
```

### 装饰器模式

#### 概念

> 装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。这种类型的设计模式属于结构型模式，它是作为现有的类的一个包装。
>
> 这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。
>
> 通过下面的实例来演示装饰器模式的用法。其中，我们将把一个形状装饰上不同的颜色，同时又不改变形状类。